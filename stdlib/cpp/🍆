#ifndef üçÜ
#define üçÜ

#include "tagged_tree.h"

#include <variant>
#include <functional>
#include <memory>
#include <type_traits>
#include <tuple>

namespace üçÜ {
	template <typename... Fs>
	struct overload : std::remove_reference_t<Fs>... {
		overload(Fs... fs) : std::remove_reference_t<Fs>{std::forward<Fs>(fs)}...{}
		using std::remove_reference_t<Fs>::operator()...;
	};

	class Null {};

	Null null;

	template<typename T>
	class StrongObject;

	class Integer;

	template<>
	class StrongObject<Integer> {
		std::variant<long long, std::shared_ptr<std::function<StrongObject<Integer>()>>> value;
	public:
		using object_type = Integer;
		StrongObject<Integer>();
		StrongObject<Integer>(const Null&);
		StrongObject<Integer>(Integer value);
		StrongObject<Integer>(long long value);
		StrongObject<Integer>(std::shared_ptr<std::function<StrongObject<Integer>()>> fun) : value(std::move(fun)) {}

		Integer& operator*();
		Integer* operator->();
		StrongObject<Integer> operator==(StrongObject<Integer> b);
		StrongObject<Integer> operator!=(StrongObject<Integer> b);

		explicit operator bool();

		long long& get_value() {
			return std::visit(overload(
			[](long long& v)->long long&{return v;},
			[&](std::shared_ptr<std::function<StrongObject<Integer>()>>& f)->long long&{
				long long val = (*f)().get_value();
				*f = [=](){
					return StrongObject<Integer>(val);
				};
				value = val;
				return std::get<long long>(value);
			}
			), value);
		}

		friend class Integer;
	};

	class Integer {
		long long value;
	public:
		Integer() = delete;
		StrongObject<Integer> fun_add(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value + o.get_value());
		}
		StrongObject<Integer> fun_sub(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value - o.get_value());
		}
		StrongObject<Integer> fun_mul(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value * o.get_value());
		}
		StrongObject<Integer> fun_div(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value / o.get_value());
		}
		StrongObject<Integer> fun_mod(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value % o.get_value());
		}
		StrongObject<Integer> fun_alt(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value || o.get_value());
		}
		StrongObject<Integer> fun_less(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value < o.get_value());
		}
		StrongObject<Integer> fun_le(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value <= o.get_value());
		}
		StrongObject<Integer> fun_more(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value > o.get_value());
		}
		StrongObject<Integer> fun_me(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value >= o.get_value());
		}
		StrongObject<Integer> fun_opp() const {
			return StrongObject<Integer>(-value);
		}
		StrongObject<Integer> fun_neg() const {
			return StrongObject<Integer>(!value);
		}
		StrongObject<Integer> fun_con(StrongObject<Integer> o) const {
			return StrongObject<Integer>(value && o.get_value());
		}
/*
		StrongObject<Integer> operator==(StrongObject<Integer> b) const {
			return StrongObject<Integer>(value == b.get_value());
		}
		StrongObject<Integer> operator!=(StrongObject<Integer> b) const {
			return StrongObject<Integer>(value != b.get_value());
		}
*/
		static Integer* cast_from(long long* value) {
			return reinterpret_cast<Integer*>(value);
		}
/*
		explicit operator bool() const {
			return value;
		}
*/
		long long& to_ll() {
			return value;
		}
	};

	StrongObject<Integer>::StrongObject() : value(0LL) {}

	StrongObject<Integer>::StrongObject(const Null&) : value(0LL) {}

	StrongObject<Integer>::StrongObject(Integer value) : value(value.to_ll()) {}

	StrongObject<Integer>::StrongObject(long long value) : value(value) {}

	Integer& StrongObject<Integer>::operator*() {
		return *Integer::cast_from(&get_value());
	}
	Integer* StrongObject<Integer>::operator->() {
		return Integer::cast_from(&get_value());
	}
	StrongObject<Integer> StrongObject<Integer>::operator==(StrongObject<Integer> b) {
		return std::visit(overload(
		[&](long long& v){return v == b.get_value();},
		[&](std::shared_ptr<std::function<StrongObject<Integer>()>>& fa){
			return std::visit(overload(
			[&](long long& v){return v == get_value();},
			[&](std::shared_ptr<std::function<StrongObject<Integer>()>>& fb){
				if(fa == fb) {
					return true;
				}
				return get_value() == b.get_value();
			}
			), b.value);
		}
		), value);
	}
	StrongObject<Integer> StrongObject<Integer>::operator!=(StrongObject<Integer> b) {
		return !(*this == b);
	}

	StrongObject<Integer>::operator bool() {
		return get_value();
	}

	template<typename T>
	class WeakObject;

	const std::shared_ptr<std::function<std::shared_ptr<void>()>> null_ptr_fun = std::make_shared<std::function<std::shared_ptr<void>()>>([]()->std::shared_ptr<void>{return nullptr;});

	template<typename T>
	class StrongObject {
		std::shared_ptr<std::function<std::shared_ptr<void>()>> obj;
		friend class WeakObject<T>;
		template<typename U>
		friend class StrongObject;
	public:
		using object_type = T;
		T& operator*() {
			return *get_value();
		}
		T* operator->() {
			return get_value().get();
		}
		StrongObject(const Null&) : obj(null_ptr_fun) {}
		StrongObject() : obj(null_ptr_fun) {}
		StrongObject(const WeakObject<T>& o);
		StrongObject(std::shared_ptr<std::function<std::shared_ptr<void>()>> fun) : obj(std::move(fun)) {}
		template<typename U, std::enable_if_t<std::is_convertible<U*, T*>::value, int> = 0>
		StrongObject(StrongObject<U> o) : obj(o.obj) {}

		template<typename... Ts>
		static StrongObject make_object(Ts&&... args) {
			StrongObject ret;
			char* memory = new char[sizeof(T)];
			std::shared_ptr<T> ptr(reinterpret_cast<T*>(memory), std::function<void(T*)>([](T* ptr){
				delete[](reinterpret_cast<char*>(ptr));
			}));
			ret.obj = std::make_shared<std::function<std::shared_ptr<void>()>>([=]()->std::shared_ptr<void>{return ptr;});
			new (reinterpret_cast<T*>(memory)) T(ret, std::forward<Ts>(args)...);
			*std::get_deleter<std::function<void(T*)>>(ptr) = [](T* ptr){
				ptr->~T();
				delete[](reinterpret_cast<char*>(ptr));
			};
			return ret;
		}

		StrongObject<Integer> operator==(StrongObject<T> b) {
			if(obj == b.obj) {
				return true;
			}
			return get_value() == b.get_value();
		}
		StrongObject<Integer> operator!=(StrongObject<T> b) {
			return !(*this == b);
		}
/*
		explicit operator bool() const {
			return obj;
		}
*/
		std::shared_ptr<T> get_value() {
			std::shared_ptr<T> val = std::static_pointer_cast<T>((*obj)());
			*obj = [=](){
				return val;
			};
			return val;
		}

		template<typename U>
		static StrongObject scast(StrongObject<U> o) {
			return StrongObject(o.obj);
		}

		template<typename U>
		static StrongObject dcast(StrongObject<U> o) {
			std::shared_ptr<U> value = o.get_value();
			if(!value) {
				return null;
			}
			return std::make_shared<std::function<std::shared_ptr<void>()>>([val{std::dynamic_pointer_cast<T>(value)}](){return val;});
		}
	};

	template<typename T>
	class WeakObject {
		std::weak_ptr<std::function<std::shared_ptr<void>()>> obj;
		friend class StrongObject<T>;
		template<typename U>
		friend class WeakObject;
	public:
		using object_type = T;
		T& operator*() {
			return *get_value();
		}
		T* operator->() {
			return get_value().get();
		}
		WeakObject(const Null&) : obj(null_ptr_fun) {}
		WeakObject(std::weak_ptr<std::function<std::shared_ptr<T>()>> obj) : obj(obj) {}
		WeakObject() : obj(null_ptr_fun) {}
		WeakObject(const StrongObject<T>& o) : obj(o.obj) {}
		template<typename U, std::enable_if_t<std::is_convertible<U*, T*>::value, int> = 0>
		WeakObject(WeakObject<U> o) : obj(o.obj) {}
		StrongObject<Integer> operator==(WeakObject<T> b) {
			return StrongObject<T>(*this) == StrongObject<T>(b);
		}
		StrongObject<Integer> operator!=(WeakObject<T> b) {
			return !(*this == b);
		}
/*
		explicit operator bool() const {
			return obj;
		}
*/
		std::shared_ptr<T> get_value() {
			auto locked = obj.lock();
			std::shared_ptr<T> val = std::static_pointer_cast<T>((*locked)());
			*locked = [=](){
				return val;
			};
			return val;
		}
	};

	template<>
	class WeakObject<Integer>;

	template<typename T>
	StrongObject<T>::StrongObject(const WeakObject<T>& o) : obj(o.obj.lock()) {}

	template<typename T, typename... Ts>
	StrongObject<T> make_object(Ts&&... args) {
		return StrongObject<T>::make_object(std::forward<Ts>(args)...);
	}

	template<typename T>
	class has_journal;

	template<>
	class has_journal<Integer> : public std::false_type {};

	template<typename T, typename P, typename U = typename P::object_type>
	StrongObject<T> dcast(P o) {
		return StrongObject<T>::dcast(StrongObject<U>(o));
	}

	template<typename T, typename P, typename U = typename P::object_type>
	StrongObject<T> scast(P o) {
		return StrongObject<T>::scast(StrongObject<U>(o));
	}

	class Journal {
		template<typename...>
		struct unpack_to_args;

		template<typename R, typename O, typename... Ts>
		struct unpack_to_args<R, O, std::tuple<Ts...>> {
			using type = R (O::*)(Ts...);
		};

		template<typename...>
		struct unpack_to_args_skip_first;

		template<typename R, typename O, typename T, typename... Ts>
		struct unpack_to_args_skip_first<R, O, std::tuple<T, Ts...>> {
			using type = R (O::*)(Ts...);
		};

		class Tag {
			using VertexType = TaggedTree<std::tuple<std::function<void()>, std::function<void()>, size_t>>::Vertex;
			std::shared_ptr<TaggedTree<std::tuple<std::function<void()>, std::function<void()>, size_t>>> tree;
			VertexType* vertex;
			Tag(decltype(tree) tree, decltype(vertex) vertex) : tree(std::move(tree)), vertex(vertex) {}
			void destroy(){
				if(tree && ((--std::get<2>(vertex->data)) == 0)) {
					vertex->untag(*tree);
					tree = nullptr;
				}
			}
			friend class Journal;
			std::pair<std::vector<Tag::VertexType*>, std::vector<Tag::VertexType*>> path_to(const Tag& t) const {
				return vertex->path_to(*t.vertex);
			}
			void force_vertex(VertexType* v) {
				++std::get<2>(v->data);
				v->tag();
				if((--std::get<2>(vertex->data)) == 0) {
					vertex->untag(*tree);
				}
				vertex = v;
			}
		public:
			Tag() = delete;
			Tag& operator=(const Tag& o) {
				destroy();
				tree = o.tree;
				vertex = o.vertex;
				++std::get<2>(vertex->data);
				return *this;
			}
			Tag& operator=(Tag&& o) {
				destroy();
				tree = std::move(o.tree);
				vertex = o.vertex;
				return *this;
			}
			Tag(const Tag& o) : tree(o.tree), vertex(o.vertex) {
				++std::get<2>(vertex->data);
			}
			Tag(Tag&& o) : tree(std::move(o.tree)), vertex(o.vertex) {}
			~Tag() {
				destroy();
			}
			static Tag make_new() {
				auto tree = TaggedTree<std::tuple<std::function<void()>, std::function<void()>, size_t>>::make_tree(std::make_tuple(std::function<void()>(), std::function<void()>(), 1));
				return Tag(std::move(tree.first), tree.second);
			}
			Tag grow(std::function<void()> there, std::function<void()> back) const {
				auto new_vertex = vertex->grow(std::make_tuple(std::move(there), std::move(back), 1));
				return Tag(tree, new_vertex);
			}
		};

		Tag tag;

		Tag get_tag() const {
			return tag;
		}
		void force_tag(const Tag& t) {
			tag = t;
		}
		void force_tag(Tag::VertexType* v) {
			tag.force_vertex(v);
		}
		
		void goto_tag(const Tag& t) {
			std::pair<std::vector<Tag::VertexType*>, std::vector<Tag::VertexType*>> path = tag.path_to(t);
			path.first.pop_back();
			for(Tag::VertexType* v : path.first) {
				std::get<1>(v->data)();
				force_tag(v->get_parent());
			}
			for(auto i = path.second.rbegin(); i != path.second.rend(); ++i) {
				std::get<0>((**i).data)();
				force_tag(*i);
			}
		}

		template<typename...>
		struct count_types_with_journal;

		template<>
		struct count_types_with_journal<> {
			count_types_with_journal() = delete;
			static constexpr size_t value = 0;
		};

		template<typename T, typename... Ts>
		struct count_types_with_journal<T, Ts...> {
			count_types_with_journal() = delete;
			static constexpr size_t value = (has_journal<T>::value ? 1 : 0) + count_types_with_journal<Ts...>::value;
		};

		template<typename T, bool journal = has_journal<T>::value>
		struct Captured;

		template<typename T>
		struct Captured<T, true> {
			using has_journal = std::true_type;
			Tag tag;
			StrongObject<T> object;
			Captured() = delete;
			Captured(const Captured&) = delete;
			Captured(Captured&&) = default;
			Captured(Tag tag, StrongObject<T> object) : tag(std::move(tag)), object(std::move(object)) {}
		};

		template<typename T>
		struct Captured<T, false> {
			using has_journal = std::false_type;
			StrongObject<T> object;
			Captured() = delete;
			Captured(const Captured&) = delete;
			Captured(Captured&&) = default;
			Captured(StrongObject<T> object) : object(std::move(object)) {}
		};

		template<typename T, typename... Ts>
		auto trim_tuple(std::tuple<T, Ts...>&& tuple) {
			return std::apply([](const auto&, auto&&... args){return std::make_tuple(std::move(args)...);}, tuple);
		}

		template<typename T, std::enable_if_t<has_journal<T>::value, int> = 0>
		static Captured<T> capture_do(StrongObject<T>& arg) {
			return Captured<T>(arg->journal.get_tag(), arg);
		}

		template<typename T, std::enable_if_t<!has_journal<T>::value, int> = 0>
		static Captured<T> capture_do(StrongObject<T>& arg) {
			return Captured<T>(arg);
		}

		template<typename... Args>
		static std::tuple<Captured<Args>...> capture(StrongObject<Args>&... args) {
			return std::make_tuple<Captured<Args>...>(capture_do(args)...);
		}

		template<typename... Args>
		static std::tuple<StrongObject<Args>&...> captured_get(std::tuple<Captured<Args>...>& args) {
			return std::apply([](Captured<Args>&... a){return std::tuple<StrongObject<Args>&...>(([](auto& arg)->decltype(arg.object)&{if constexpr (std::remove_reference<decltype(arg)>::type::has_journal::value) {arg.object->journal.goto_tag(arg.tag);} return arg.object;}(a))...);}, args);
		}

		template<typename T>
		static std::tuple<Tag> get_tags_do(const Captured<T, true>& a) {
			return {a.tag};
		}

		template<typename T>
		static std::tuple<> get_tags_do(const Captured<T, false>&) {
			return {};
		}

		template<typename... Args>
		static std::array<Tag, count_types_with_journal<Args...>::value> get_tags(const Captured<Args>&... args) {
			return std::apply([](auto&&... args){return std::array<Tag, count_types_with_journal<Args...>::value>{std::forward<decltype(args)>(args)...};}, std::tuple_cat(get_tags_do(args)...));
		}

		template<size_t i, size_t j>
		static void goto_tags_do(const std::array<Tag, j>&) {}

		template<size_t i, size_t j, typename T, typename... Args>
		static void goto_tags_do(const std::array<Tag, j>& tags, Captured<T, true>& arg, Captured<Args>&... args) {
			arg.object->journal.goto_tag(tags[i]);
			goto_tags_do<i + 1>(tags, args...);
		}

		template<size_t i, size_t j, typename T, typename... Args>
		static void goto_tags_do(const std::array<Tag, j>& tags, Captured<T, false>&, Captured<Args>&... args) {
			goto_tags_do<i>(tags, args...);
		}

		template<typename... Args>
		static void goto_tags(const std::array<Tag, count_types_with_journal<Args...>::value>& tags, std::tuple<Captured<Args>...>& args) {
			std::apply([&tags](auto&... a){goto_tags_do<0>(tags, a...);}, args);
		}

		void add_new_vertex(std::function<void()> there, std::function<void()> back) {
			tag = tag.grow(std::move(there), std::move(back));
		}

		template<typename F>
		std::function<void()> wrap_lambda(F&& lambda) {
			return [f{std::make_shared<std::remove_reference_t<F>>(std::forward<F>(lambda))}](){(*f)();};
		}
	public:
		Journal() : tag(Tag::make_new()) {}
		template<typename O, typename R, std::enable_if_t<!std::is_same_v<R, void>, int> = 0, typename... Args>
		R add_commit_noeffect(StrongObject<O> obj, std::tuple<R> (O::*basefun)(StrongObject<Args>...), StrongObject<Args>... args) {
			Tag tag = get_tag();
			R val = std::get<0>(((*obj).*basefun)(args...));
			force_tag(tag);
			return val;
		}

		template<typename O, typename... Args>
		void add_commit_noeffect(StrongObject<O> obj, void (O::*basefun)(StrongObject<Args>...), StrongObject<Args>... args) {
			Tag tag = get_tag();
			((*obj).*basefun)(args...);
			force_tag(tag);
		}

		template<typename O, typename R, std::enable_if_t<!std::is_same_v<R, void>, int> = 0, typename... Args>
		void add_commit_dual(StrongObject<O> obj, R (O::*basefun)(StrongObject<Args>...), typename unpack_to_args<void, O, R>::type dualfun, StrongObject<Args>... args) {
			auto there_args = capture(args...);
			auto dual_args = std::apply([this](auto... args){return capture(args...);}, ((*obj).*basefun)(args...));
			auto there = [there_args{std::move(there_args)}, obj, basefun]() mutable {
				auto old_arg_tags = std::apply([](const auto&... a){return Journal::get_tags(a...);}, there_args);
				std::apply([obj, basefun](auto... a)mutable{((*obj).*basefun)(a...);}, captured_get(there_args));
				goto_tags(old_arg_tags, there_args);
			};
			auto back = [dual_args{std::move(dual_args)}, obj, dualfun]() mutable {
				auto old_arg_tags = std::apply([](const auto&... a){return Journal::get_tags(a...);}, dual_args);
				std::apply([obj, dualfun](auto... a)mutable{((*obj).*dualfun)(a...);}, captured_get(dual_args));
				goto_tags(old_arg_tags, dual_args);
			};
			add_new_vertex(wrap_lambda(std::move(there)), wrap_lambda(std::move(back)));
		}

		template<typename O, typename... Args>
		void add_commit_dual(StrongObject<O> obj, void (O::*basefun)(StrongObject<Args>...), void (O::*dualfun)(), StrongObject<Args>... args) {
			auto there_args = capture(args...);
			((*obj).*basefun)(args...);
			auto there = [there_args{std::move(there_args)}, obj, basefun]() mutable {
				auto old_arg_tags = std::apply([](const auto&... a){return Journal::get_tags(a...);}, there_args);
				std::apply([obj, basefun](auto... a)mutable{((*obj).*basefun)(a...);}, captured_get(there_args));
				goto_tags(old_arg_tags, there_args);
			};
			auto back = [obj, dualfun]() mutable {
				((*obj).*dualfun)();
			};
			add_new_vertex(wrap_lambda(std::move(there)), wrap_lambda(std::move(back)));
		}

		template<typename O, typename R, std::enable_if_t<!std::is_same_v<R, void>, int> = 0, typename... Args>
		std::tuple_element_t<0, R> add_commit_dual(StrongObject<O> obj, R (O::*basefun)(StrongObject<Args>...), typename unpack_to_args_skip_first<void, O, R>::type dualfun, StrongObject<Args>... args) {
			auto there_args = capture(args...);
			auto fun_ret = ((*obj).*basefun)(args...);
			std::tuple_element_t<0, R> return_value = std::move(std::get<0>(fun_ret));
			auto dual_args = std::apply([](auto... args){return capture(args...);}, trim_tuple(std::move(fun_ret)));
			auto there = [there_args{std::move(there_args)}, obj, basefun]() mutable {
				auto old_arg_tags = std::apply([](const auto&... a){return Journal::get_tags(a...);}, there_args);
				std::apply([obj, basefun](auto... a)mutable{((*obj).*basefun)(a...);}, captured_get(there_args));
				goto_tags(old_arg_tags, there_args);
			};
			auto back = [dual_args{std::move(dual_args)}, obj, dualfun]() mutable {
				auto old_arg_tags = std::apply([](const auto&... a){return Journal::get_tags(a...);}, dual_args);
				std::apply([obj, dualfun](auto... a)mutable{((*obj).*dualfun)(a...);}, captured_get(dual_args));
				goto_tags(old_arg_tags, dual_args);
			};
			add_new_vertex(wrap_lambda(std::move(there)), wrap_lambda(std::move(back)));
			return return_value;
		}

		template<typename O, typename R, std::enable_if_t<!std::is_same_v<R, void>, int> = 0, typename... Args>
		StrongObject<R> add_commit_dual(StrongObject<O> obj, std::tuple<StrongObject<R>> (O::*basefun)(StrongObject<Args>...), void (O::*dualfun)(), StrongObject<Args>... args) {
			auto there_args = capture(args...);
			auto fun_ret = ((*obj).*basefun)(args...);
			auto there = [there_args{std::move(there_args)}, obj, basefun]() mutable {
				auto old_arg_tags = std::apply([](const auto&... a){return Journal::get_tags(a...);}, there_args);
				std::apply([obj, basefun](auto... a)mutable{((*obj).*basefun)(a...);}, captured_get(there_args));
				goto_tags(old_arg_tags, there_args);
			};
			auto back = [obj, dualfun]() mutable {
				((*obj).*dualfun)();
			};
			add_new_vertex(wrap_lambda(std::move(there)), wrap_lambda(std::move(back)));
			return std::move(std::get<0>(fun_ret));
		}
	};
}

#include "overrides.h"

#endif
