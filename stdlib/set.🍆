import "container.üçÜ"
import "avl_.üçÜ"
import "integer.üçÜ"
import "pair.üçÜ"

UntaggedSet T : Container<T, AVLNode_<T>> {
	int size_;
	strong Comparator<T> comparator_;
	strong AVLNode_<T> root_;
	weak AVLNode_<T> end_;
	constructor(Comparator<T> c) () {
		comparator_ = c;
		root_ = new AVLNode_<T>(null, null);
		end_ = root_;
	};
	fun int size() {
		return size_;
	} noeffect;
	fun AVLNode_<T> begin() {
		var AVLNode_<T> b = root_;
		while(b.left_son != null) {
			b = b.left_son;
		}
		return b;
	} noeffect;
	fun AVLNode_<T> end() {
		return end_;
	} noeffect;
	fun AVLNode_<T> find(T key) {
		var AVLNode_<T> node = root_;
		while(node != null) {
			if(node == end_) {
				if(node.left_son != null) {
					node = node.left_son;
					continue;
				} else {
					break;
				}
			}
			var T k = node.deref();
			if(comparator_.eq(key, k)) {
				return node;
			}
			if(comparator_.less(key, k)) {
				node = node.left_son;
			} else {
				node = node.right_son;
			}
		}
		return end_;
	} noeffect;

	/*
	fun void print_structural_(AVLNode_<T> node, OutputStream out){
		if(node == null) {
			out.print_string("");
		out.flush();
			return;
		}
		if(node.deref() != null) {
			node.deref().print(:out);
		out.flush();
		} else {
			out.print_string("null");
		out.flush();
		}
		out.print_string(": H ");
		out.flush();
		out.print_int(node.height);
		out.flush();
		out.print_string(": P ");
		out.flush();
		if(node.parent != null) {
			if(node.parent.deref() != null) {
				node.parent.deref().print(:out);
		out.flush();
			} else {
				out.print_string("null");
		out.flush();
			}
		}
		out.print_string(" {");
		out.flush();
		print_structural_(node.left_son, out);
		out.print_string(", ");
		out.flush();
		print_structural_(node.right_son, out);
		out.print_string("}");
		out.flush();
	} noeffect;

	fun void print_structural(OutputStream out){
		out.print_int(size_);
		out.print_string(" ");
		print_structural_(root_, out);
	} noeffect;

	That's just for debug.
	*/

	fun AVLNode_<T> rebalance_(AVLNode_<T> z) {
		var int bal = z.recalc_height();
		if(bal == -2) {
			if(z.left_son.recalc_height() == 1) {
				z.left_son.left_rotate();
			}
			if(z == root_) {
				root_ = z.left_son;
			}
			z.right_rotate();
			z = z.parent;
		} else  if (bal == 2) {
			if(z.right_son.recalc_height() == -1) {
				z.right_son.right_rotate();
			}
			if(z == root_) {
				root_ = z.right_son;
			}
			z.left_rotate();
			z = z.parent;
		}
		return z.parent;
	} noeffect;

	fun Pair<Integer, T> insert(T entry) {
		return this.insert_(entry, :new AVLNode_<T>(null, null));
	} auto;

	fun Pair<Integer, T> insert_(T entry, AVLNode_<T> use_node) {
		var AVLNode_<T> node = root_;
		while(1) {
			if(node == end_) {
				if(node.left_son != null) {
					node = node.left_son;
					continue;
				} else {
					use_node.data = entry;
					use_node.parent = node;
					node.left_son = use_node;
					node = node.left_son;
					break;
				}
			}
			var T k = node.deref();
			if(comparator_.eq(entry, k)) {
				var T old = node.deref();
				node.set(entry);
				return new Pair<Integer, T>(new Integer(1), old), old, 1;
			}
			if(comparator_.less(entry, k)) {
				if(node.left_son != null) {
					node = node.left_son;
				} else {
					use_node.data = entry;
					use_node.parent = node;
					node.left_son = use_node;
					node = node.left_son;
					break;
				}
			} else {
				if(node.right_son != null) {
					node = node.right_son;
				} else {
					use_node.data = entry;
					use_node.parent = node;
					node.right_son = use_node;
					node = node.right_son;
					break;
				}
			}
		}
		while(node != null) {
			node = rebalance_(node);
		}
		size_ = size_ + 1;
		return new Pair<Integer, T>(new Integer(0), null), entry, 0;
	} dual (T old, int had_old) {
		if(had_old) {
			insert_(old, null);
		} else {
			erase_iter(find(old));
		}
	};

	fun Pair<Integer, T> erase(T key) {
		return this.erase_iter(:find(key));
	} auto;

	fun void swap_(AVLNode_<T> a, AVLNode_<T> b) {
		auto old_root = root_;

		auto c = a.parent;
		a.parent = b.parent;
		b.parent = c;
		if(a.parent != null) {
			if(a.parent.left_son == b) {
				a.parent.left_son = a;
			} else {
				a.parent.right_son = a;
			}
		} else {
			root_ = a;
		}
		if(b.parent != null) {
			if(b.parent.left_son == a) {
				b.parent.left_son = b;
			} else {
				b.parent.right_son = b;
			}
		} else {
			root_ = b;
		}

		c = a.right_son;
		a.right_son = b.right_son;
		b.right_son = c;
		if(a.right_son != null) {
			a.right_son.parent = a;
		}
		if(b.right_son != null) {
			b.right_son.parent = b;
		}

		c = a.left_son;
		a.left_son = b.left_son;
		b.left_son = c;
		if(a.left_son != null) {
			a.left_son.parent = a;
		}
		if(b.left_son != null) {
			b.left_son.parent = b;
		}
	} noeffect;

	fun Pair<Integer, T> erase_iter(AVLNode_<T> node) {
		while(1) {
			if(node.eq(end_)) {
				return new Pair<Integer, T>(new Integer(0), null), null, null;
			}
			if(node.left_son == null && node.right_son == null) {
				if(node.parent.left_son == node) {
					node.parent.left_son = null;
				} else {
					node.parent.right_son = null;
				}
			} else if (node.left_son != null && node.right_son == null) {
				node.left_son.parent = node.parent;
				if(node.parent != null) {
					if(node.parent.left_son == node) {
						node.parent.left_son = node.left_son;
					} else {
						node.parent.right_son = node.left_son;
					}
				} else {
					root_ = node.left_son;
				}
			} else if (node.left_son == null && node.right_son != null) {
				node.right_son.parent = node.parent;
				if(node.parent != null) {
					if(node.parent.left_son == node) {
						node.parent.left_son = node.right_son;
					} else {
						node.parent.right_son = node.right_son;
					}
				} else {
					root_ = node.right_son;
				}
			} else {
				swap_(node, node.next());
				continue;
			}
			break;
		}
		var T old = node.deref();
		auto old_node = node;
		node = node.parent;
		while(node != null) {
			node = rebalance_(node);
		}
		old_node.data = null;
		old_node.height = null;
		old_node.parent = null;
		old_node.left_son = null;
		old_node.right_son = null;
		size_ = size_ - 1;
		return new Pair<Integer, T>(new Integer(1), old), old, old_node;
	} dual (T old, AVLNode_<T> use_node) {
		if(use_node != null) {
			insert_(old, use_node);
		}
	};
}
